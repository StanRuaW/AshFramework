
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{

    bool condition::MinMaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(min)) return false;
        if(!_buf.readInt(max)) return false;

        return true;
    }

    bool condition::MinMaxLevel::deserializeMinMaxLevel(ByteBuf& _buf, ::bright::SharedPtr<condition::MinMaxLevel>& _out)
    {
        _out.reset(new condition::MinMaxLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MinMaxLevel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::ClothesPropertyScoreGreaterThan::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; prop = item::EClothesPropertyType(__enum_temp__); }
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool condition::ClothesPropertyScoreGreaterThan::deserializeClothesPropertyScoreGreaterThan(ByteBuf& _buf, ::bright::SharedPtr<condition::ClothesPropertyScoreGreaterThan>& _out)
    {
        _out.reset(new condition::ClothesPropertyScoreGreaterThan());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::ClothesPropertyScoreGreaterThan::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::ContainsItem::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if (!_buf.readBool(reverse)) return false;

        return true;
    }

    bool condition::ContainsItem::deserializeContainsItem(ByteBuf& _buf, ::bright::SharedPtr<condition::ContainsItem>& _out)
    {
        _out.reset(new condition::ContainsItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::ContainsItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool item::ChooseOneBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(dropId)) return false;
        if (!_buf.readBool(isUnique)) return false;

        return true;
    }

    bool item::ChooseOneBonus::deserializeChooseOneBonus(ByteBuf& _buf, ::bright::SharedPtr<item::ChooseOneBonus>& _out)
    {
        _out.reset(new item::ChooseOneBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::ChooseOneBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->dropId_Ref = ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(dropId);
    }

    bool item::InteractionItem::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { attackNum.reset(new ::bright::int32()); if(!_buf.readInt(*attackNum)) return false; } else { attackNum.reset(); } }
        if(!_buf.readString(holdingStaticMesh)) return false;
        if(!_buf.readString(holdingStaticMeshMat)) return false;

        return true;
    }

    bool item::InteractionItem::deserializeInteractionItem(ByteBuf& _buf, ::bright::SharedPtr<item::InteractionItem>& _out)
    {
        _out.reset(new item::InteractionItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::InteractionItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::Clothes::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(attack)) return false;
        if(!_buf.readLong(hp)) return false;
        if(!_buf.readInt(energyLimit)) return false;
        if(!_buf.readInt(energyResume)) return false;

        return true;
    }

    bool item::Clothes::deserializeClothes(ByteBuf& _buf, ::bright::SharedPtr<item::Clothes>& _out)
    {
        _out.reset(new item::Clothes());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Clothes::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::DesignDrawing::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); learnComponentId.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; learnComponentId.push_back(_e);}}

        return true;
    }

    bool item::DesignDrawing::deserializeDesignDrawing(ByteBuf& _buf, ::bright::SharedPtr<item::DesignDrawing>& _out)
    {
        _out.reset(new item::DesignDrawing());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::DesignDrawing::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
    }

    bool item::Dymmy::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!cost::Cost::deserializeCost(_buf, cost)) return false;

        return true;
    }

    bool item::Dymmy::deserializeDymmy(ByteBuf& _buf, ::bright::SharedPtr<item::Dymmy>& _out)
    {
        _out.reset(new item::Dymmy());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Dymmy::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
        cost->resolve(_tables);
    }

    bool cost::Cost::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool cost::Cost::deserializeCost(ByteBuf& _buf, ::bright::SharedPtr<cost::Cost>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case cost::CostCurrency::ID: { _out.reset(new cost::CostCurrency()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostCurrencies::ID: { _out.reset(new cost::CostCurrencies()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostOneItem::ID: { _out.reset(new cost::CostOneItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostItem::ID: { _out.reset(new cost::CostItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case cost::CostItems::ID: { _out.reset(new cost::CostItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void cost::Cost::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool cost::CostCurrency::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = item::ECurrencyType(__enum_temp__); }
        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool cost::CostCurrency::deserializeCostCurrency(ByteBuf& _buf, ::bright::SharedPtr<cost::CostCurrency>& _out)
    {
        _out.reset(new cost::CostCurrency());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostCurrency::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
    }

    bool cost::CostCurrencies::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); currencies.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<cost::CostCurrency> _e;  if(!cost::CostCurrency::deserializeCostCurrency(_buf, _e)) return false; currencies.push_back(_e);}}

        return true;
    }

    bool cost::CostCurrencies::deserializeCostCurrencies(ByteBuf& _buf, ::bright::SharedPtr<cost::CostCurrencies>& _out)
    {
        _out.reset(new cost::CostCurrencies());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostCurrencies::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        for(auto _e : currencies) { _e->resolve(_tables); }
    }

    bool cost::CostOneItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool cost::CostOneItem::deserializeCostOneItem(ByteBuf& _buf, ::bright::SharedPtr<cost::CostOneItem>& _out)
    {
        _out.reset(new cost::CostOneItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostOneItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool cost::CostItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool cost::CostItem::deserializeCostItem(ByteBuf& _buf, ::bright::SharedPtr<cost::CostItem>& _out)
    {
        _out.reset(new cost::CostItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostItem::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool cost::CostItems::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));itemList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<cost::CostItem> _e;if(!cost::CostItem::deserializeCostItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool cost::CostItems::deserializeCostItems(ByteBuf& _buf, ::bright::SharedPtr<cost::CostItems>& _out)
    {
        _out.reset(new cost::CostItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void cost::CostItems::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        Cost::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool l10n::L10NDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(text)) return false;

        return true;
    }

    bool l10n::L10NDemo::deserializeL10NDemo(ByteBuf& _buf, ::bright::SharedPtr<l10n::L10NDemo>& _out)
    {
        _out.reset(new l10n::L10NDemo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void l10n::L10NDemo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool l10n::PatchDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool l10n::PatchDemo::deserializePatchDemo(ByteBuf& _buf, ::bright::SharedPtr<l10n::PatchDemo>& _out)
    {
        _out.reset(new l10n::PatchDemo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void l10n::PatchDemo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool mail::SystemMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(title)) return false;
        if(!_buf.readString(sender)) return false;
        if(!_buf.readString(content)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); award.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}

        return true;
    }

    bool mail::SystemMail::deserializeSystemMail(ByteBuf& _buf, ::bright::SharedPtr<mail::SystemMail>& _out)
    {
        _out.reset(new mail::SystemMail());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void mail::SystemMail::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool mail::GlobalMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(title)) return false;
        if(!_buf.readString(sender)) return false;
        if(!_buf.readString(content)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); award.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}
        if (!_buf.readBool(allServer)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); serverList.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; serverList.push_back(_e);}}
        if(!_buf.readString(platform)) return false;
        if(!_buf.readString(channel)) return false;
        if(!condition::MinMaxLevel::deserializeMinMaxLevel(_buf, minMaxLevel)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, registerTime)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, mailTime)) return false;

        return true;
    }

    bool mail::GlobalMail::deserializeGlobalMail(ByteBuf& _buf, ::bright::SharedPtr<mail::GlobalMail>& _out)
    {
        _out.reset(new mail::GlobalMail());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void mail::GlobalMail::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        minMaxLevel->resolve(_tables);
        registerTime->resolve(_tables);
        mailTime->resolve(_tables);
    }

    bool role::LevelExpAttr::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(level)) return false;
        if(!_buf.readLong(needExp)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); clothesAttrs.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; clothesAttrs.push_back(_e);}}

        return true;
    }

    bool role::LevelExpAttr::deserializeLevelExpAttr(ByteBuf& _buf, ::bright::SharedPtr<role::LevelExpAttr>& _out)
    {
        _out.reset(new role::LevelExpAttr());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::LevelExpAttr::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool role::LevelBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); distinctBonusInfos.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<role::DistinctBonusInfos> _e;  if(!role::DistinctBonusInfos::deserializeDistinctBonusInfos(_buf, _e)) return false; distinctBonusInfos.push_back(_e);}}

        return true;
    }

    bool role::LevelBonus::deserializeLevelBonus(ByteBuf& _buf, ::bright::SharedPtr<role::LevelBonus>& _out)
    {
        _out.reset(new role::LevelBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::LevelBonus::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : distinctBonusInfos) { _e->resolve(_tables); }
    }

    bool role::DistinctBonusInfos::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(effectiveLevel)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); bonusInfo.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<role::BonusInfo> _e;  if(!role::BonusInfo::deserializeBonusInfo(_buf, _e)) return false; bonusInfo.push_back(_e);}}

        return true;
    }

    bool role::DistinctBonusInfos::deserializeDistinctBonusInfos(ByteBuf& _buf, ::bright::SharedPtr<role::DistinctBonusInfos>& _out)
    {
        _out.reset(new role::DistinctBonusInfos());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::DistinctBonusInfos::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : bonusInfo) { _e->resolve(_tables); }
    }

    bool role::BonusInfo::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = item::ECurrencyType(__enum_temp__); }
        if(!_buf.readFloat(coefficient)) return false;

        return true;
    }

    bool role::BonusInfo::deserializeBonusInfo(ByteBuf& _buf, ::bright::SharedPtr<role::BonusInfo>& _out)
    {
        _out.reset(new role::BonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void role::BonusInfo::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool tag::TestTag::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(value)) return false;

        return true;
    }

    bool tag::TestTag::deserializeTestTag(ByteBuf& _buf, ::bright::SharedPtr<tag::TestTag>& _out)
    {
        _out.reset(new tag::TestTag());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void tag::TestTag::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoType2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x4)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readByte(x2)) return false;
        if(!_buf.readShort(x3)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readDouble(x7)) return false;
        if(!_buf.readFshort(x80)) return false;
        if(!_buf.readFint(x8)) return false;
        if(!_buf.readFlong(x9)) return false;
        if(!_buf.readString(x10)) return false;
        if(!test::DemoType1::deserializeDemoType1(_buf, x12)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::DemoEnum(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readString(s1)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readVector3(v3)) return false;
        if(!_buf.readVector4(v4)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; k2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k5.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;  if(!_buf.readInt(_e)) return false; k5.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k15.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoDynamic> _e;if(!test::DemoDynamic::deserializeDemoDynamic(_buf, _e)) return false; k15.push_back(_e);}}

        return true;
    }

    bool test::DemoType2::deserializeDemoType2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoType2>& _out)
    {
        _out.reset(new test::DemoType2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoType2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->x3_Ref = ((test::TbFullTypes*)(_tables["test.TbFullTypes"]))->get(x3);
        x12->resolve(_tables);
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
        for(auto _e : k15) { _e->resolve(_tables); }
    }

    bool test::DemoType1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;

        return true;
    }

    bool test::DemoType1::deserializeDemoType1(ByteBuf& _buf, ::bright::SharedPtr<test::DemoType1>& _out)
    {
        _out.reset(new test::DemoType1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoType1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoDynamic::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;

        return true;
    }

    bool test::DemoDynamic::deserializeDemoDynamic(ByteBuf& _buf, ::bright::SharedPtr<test::DemoDynamic>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case test::DemoD2::ID: { _out.reset(new test::DemoD2()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case test::DemoE1::ID: { _out.reset(new test::DemoE1()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case test::DemoD5::ID: { _out.reset(new test::DemoD5()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void test::DemoDynamic::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoD2::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x2)) return false;

        return true;
    }

    bool test::DemoD2::deserializeDemoD2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD2>& _out)
    {
        _out.reset(new test::DemoD2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoD2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
    }

    bool test::DemoD3::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x3)) return false;

        return true;
    }

    bool test::DemoD3::deserializeDemoD3(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD3>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case test::DemoE1::ID: { _out.reset(new test::DemoE1()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void test::DemoD3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
    }

    bool test::DemoE1::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoD3::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(x4)) return false;

        return true;
    }

    bool test::DemoE1::deserializeDemoE1(ByteBuf& _buf, ::bright::SharedPtr<test::DemoE1>& _out)
    {
        _out.reset(new test::DemoE1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoE1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoD3::resolve(_tables);
    }

    bool test::DemoD5::deserialize(ByteBuf& _buf)
    {
        if (!test::DemoDynamic::deserialize(_buf))
        {
            return false;
        }

        if(!test::DateTimeRange::deserializeDateTimeRange(_buf, time)) return false;

        return true;
    }

    bool test::DemoD5::deserializeDemoD5(ByteBuf& _buf, ::bright::SharedPtr<test::DemoD5>& _out)
    {
        _out.reset(new test::DemoD5());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoD5::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        DemoDynamic::resolve(_tables);
        time->resolve(_tables);
    }

    bool test::DateTimeRange::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(startTime)) return false;
        if(!_buf.readInt(endTime)) return false;

        return true;
    }

    bool test::DateTimeRange::deserializeDateTimeRange(ByteBuf& _buf, ::bright::SharedPtr<test::DateTimeRange>& _out)
    {
        _out.reset(new test::DateTimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DateTimeRange::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoE2::deserialize(ByteBuf& _buf)
    {

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { y1.reset(new ::bright::int32()); if(!_buf.readInt(*y1)) return false; } else { y1.reset(); } }
        if (!_buf.readBool(y2)) return false;

        return true;
    }

    bool test::DemoE2::deserializeDemoE2(ByteBuf& _buf, ::bright::SharedPtr<test::DemoE2>& _out)
    {
        _out.reset(new test::DemoE2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoE2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoSingletonType::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, date)) return false;

        return true;
    }

    bool test::DemoSingletonType::deserializeDemoSingletonType(ByteBuf& _buf, ::bright::SharedPtr<test::DemoSingletonType>& _out)
    {
        _out.reset(new test::DemoSingletonType());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoSingletonType::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        date->resolve(_tables);
    }

    bool test::MultiRowRecord::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); oneRows.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; oneRows.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); multiRows1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; multiRows1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));multiRows2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; multiRows2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); multiRows3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType2> _e;  if(!test::MultiRowType2::deserializeMultiRowType2(_buf, _e)) return false; multiRows3.insert(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); multiRows4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::SharedPtr<test::MultiRowType2> _v;  if(!test::MultiRowType2::deserializeMultiRowType2(_buf, _v)) return false;     multiRows4[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); multiRows5.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType3> _e;  if(!test::MultiRowType3::deserializeMultiRowType3(_buf, _e)) return false; multiRows5.push_back(_e);}}

        return true;
    }

    bool test::MultiRowRecord::deserializeMultiRowRecord(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowRecord>& _out)
    {
        _out.reset(new test::MultiRowRecord());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowRecord::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : oneRows) { _e->resolve(_tables); }
        for(auto _e : multiRows1) { _e->resolve(_tables); }
        for(auto _e : multiRows2) { _e->resolve(_tables); }
        for(auto _e : multiRows4) { _e.second->resolve(_tables); }
        for(auto _e : multiRows5) { _e->resolve(_tables); }
    }

    bool test::MultiRowType1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x)) return false;

        return true;
    }

    bool test::MultiRowType1::deserializeMultiRowType1(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType1>& _out)
    {
        _out.reset(new test::MultiRowType1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiRowType2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x)) return false;
        if(!_buf.readFloat(y)) return false;

        return true;
    }

    bool test::MultiRowType2::deserializeMultiRowType2(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType2>& _out)
    {
        _out.reset(new test::MultiRowType2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::MultiRowType3::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); items.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::MultiRowType1> _e;  if(!test::MultiRowType1::deserializeMultiRowType1(_buf, _e)) return false; items.push_back(_e);}}

        return true;
    }

    bool test::MultiRowType3::deserializeMultiRowType3(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowType3>& _out)
    {
        _out.reset(new test::MultiRowType3());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowType3::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : items) { _e->resolve(_tables); }
    }

    bool test::MultiRowTitle::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!test::H1::deserializeH1(_buf, x1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;  if(!test::H2::deserializeH2(_buf, _e)) return false; x2.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));x3.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::H2> _e;if(!test::H2::deserializeH2(_buf, _e)) return false; x3.push_back(_e);}}

        return true;
    }

    bool test::MultiRowTitle::deserializeMultiRowTitle(ByteBuf& _buf, ::bright::SharedPtr<test::MultiRowTitle>& _out)
    {
        _out.reset(new test::MultiRowTitle());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::MultiRowTitle::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x1->resolve(_tables);
        for(auto _e : x2) { _e->resolve(_tables); }
        for(auto _e : x3) { _e->resolve(_tables); }
    }

    bool test::H1::deserialize(ByteBuf& _buf)
    {

        if(!test::H2::deserializeH2(_buf, y2)) return false;
        if(!_buf.readInt(y3)) return false;

        return true;
    }

    bool test::H1::deserializeH1(ByteBuf& _buf, ::bright::SharedPtr<test::H1>& _out)
    {
        _out.reset(new test::H1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::H1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        y2->resolve(_tables);
    }

    bool test::H2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(z2)) return false;
        if(!_buf.readInt(z3)) return false;

        return true;
    }

    bool test::H2::deserializeH2(ByteBuf& _buf, ::bright::SharedPtr<test::H2>& _out)
    {
        _out.reset(new test::H2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::H2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestNull::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x1.reset(new ::bright::int32()); if(!_buf.readInt(*x1)) return false; } else { x1.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x2.reset(new test::DemoEnum()); {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; *x2 = test::DemoEnum(__enum_temp__); } } else { x2.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x3.reset(); if(!test::DemoType1::deserializeDemoType1(_buf, x3)) return false; } else { x3.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x4.reset(); if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x4)) return false; } else { x4.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s1.reset(new ::bright::String()); if(!_buf.readString(*s1)) return false; } else { s1.reset(); } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s2.reset(new ::bright::String()); if(!_buf.readString(*s2)) return false; } else { s2.reset(); } }

        return true;
    }

    bool test::TestNull::deserializeTestNull(ByteBuf& _buf, ::bright::SharedPtr<test::TestNull>& _out)
    {
        _out.reset(new test::TestNull());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestNull::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        if (x3 != nullptr) x3->resolve(_tables);
        if (x4 != nullptr) x4->resolve(_tables);
    }

    bool test::DemoPrimitiveTypesTable::deserialize(ByteBuf& _buf)
    {

        if (!_buf.readBool(x1)) return false;
        if(!_buf.readByte(x2)) return false;
        if(!_buf.readShort(x3)) return false;
        if(!_buf.readInt(x4)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readDouble(x7)) return false;
        if(!_buf.readString(s1)) return false;
        if(!_buf.readString(s2)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readVector3(v3)) return false;
        if(!_buf.readVector4(v4)) return false;
        if(!_buf.readInt(t1)) return false;

        return true;
    }

    bool test::DemoPrimitiveTypesTable::deserializeDemoPrimitiveTypesTable(ByteBuf& _buf, ::bright::SharedPtr<test::DemoPrimitiveTypesTable>& _out)
    {
        _out.reset(new test::DemoPrimitiveTypesTable());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoPrimitiveTypesTable::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestString::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(s1)) return false;
        if(!test::CompactString::deserializeCompactString(_buf, cs1)) return false;
        if(!test::CompactString::deserializeCompactString(_buf, cs2)) return false;

        return true;
    }

    bool test::TestString::deserializeTestString(ByteBuf& _buf, ::bright::SharedPtr<test::TestString>& _out)
    {
        _out.reset(new test::TestString());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestString::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        cs1->resolve(_tables);
        cs2->resolve(_tables);
    }

    bool test::CompactString::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(s2)) return false;
        if(!_buf.readString(s3)) return false;

        return true;
    }

    bool test::CompactString::deserializeCompactString(ByteBuf& _buf, ::bright::SharedPtr<test::CompactString>& _out)
    {
        _out.reset(new test::CompactString());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::CompactString::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DemoGroup::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(x1)) return false;
        if(!_buf.readInt(x2)) return false;
        if(!_buf.readInt(x3)) return false;
        if(!_buf.readInt(x4)) return false;
        if(!test::InnerGroup::deserializeInnerGroup(_buf, x5)) return false;

        return true;
    }

    bool test::DemoGroup::deserializeDemoGroup(ByteBuf& _buf, ::bright::SharedPtr<test::DemoGroup>& _out)
    {
        _out.reset(new test::DemoGroup());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DemoGroup::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        x5->resolve(_tables);
    }

    bool test::InnerGroup::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(y1)) return false;
        if(!_buf.readInt(y2)) return false;
        if(!_buf.readInt(y3)) return false;
        if(!_buf.readInt(y4)) return false;

        return true;
    }

    bool test::InnerGroup::deserializeInnerGroup(ByteBuf& _buf, ::bright::SharedPtr<test::InnerGroup>& _out)
    {
        _out.reset(new test::InnerGroup());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::InnerGroup::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestGlobal::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(unlockEquip)) return false;
        if(!_buf.readInt(unlockHero)) return false;

        return true;
    }

    bool test::TestGlobal::deserializeTestGlobal(ByteBuf& _buf, ::bright::SharedPtr<test::TestGlobal>& _out)
    {
        _out.reset(new test::TestGlobal());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestGlobal::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DetectEncoding::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;

        return true;
    }

    bool test::DetectEncoding::deserializeDetectEncoding(ByteBuf& _buf, ::bright::SharedPtr<test::DetectEncoding>& _out)
    {
        _out.reset(new test::DetectEncoding());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DetectEncoding::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::DefineFromExcel::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readInt(x8)) return false;
        if(!_buf.readString(x10)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::ETestQuality(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}

        return true;
    }

    bool test::DefineFromExcel::deserializeDefineFromExcel(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcel>& _out)
    {
        _out.reset(new test::DefineFromExcel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcel::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->x8_Ref = ((test::TbDemoPrimitive*)(_tables["test.TbDemoPrimitive"]))->get(x8);
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
    }

    bool test::DefineFromExcelOne::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(unlockEquip)) return false;
        if(!_buf.readInt(unlockHero)) return false;
        if(!_buf.readString(defaultAvatar)) return false;
        if(!_buf.readString(defaultItem)) return false;

        return true;
    }

    bool test::DefineFromExcelOne::deserializeDefineFromExcelOne(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcelOne>& _out)
    {
        _out.reset(new test::DefineFromExcelOne());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcelOne::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }

    bool test::TestJson2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); m1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     m1[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); m2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int64 _k;  if(!_buf.readLong(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     m2[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); m3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::String _k;  if(!_buf.readString(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     m3[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); m4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::String _k;  if(!_buf.readString(_k)) return false; ::bright::SharedPtr<test::DemoType1> _v;  if(!test::DemoType1::deserializeDemoType1(_buf, _v)) return false;     m4[_k] = _v;}}

        return true;
    }

    bool test::TestJson2::deserializeTestJson2(ByteBuf& _buf, ::bright::SharedPtr<test::TestJson2>& _out)
    {
        _out.reset(new test::TestJson2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestJson2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : m4) { _e.second->resolve(_tables); }
    }

    bool test::TestIndex::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); eles.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoType1> _e;  if(!test::DemoType1::deserializeDemoType1(_buf, _e)) return false; eles.push_back(_e);}}
        for(auto& _v : this->eles)
        { 
            eles_Index.insert({_v->x1, _v});
        }

        return true;
    }

    bool test::TestIndex::deserializeTestIndex(ByteBuf& _buf, ::bright::SharedPtr<test::TestIndex>& _out)
    {
        _out.reset(new test::TestIndex());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestIndex::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        for(auto _e : eles) { _e->resolve(_tables); }
    }

    bool test::DefineFromExcel2::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if (!_buf.readBool(x1)) return false;
        if(!_buf.readLong(x5)) return false;
        if(!_buf.readFloat(x6)) return false;
        if(!_buf.readInt(x8)) return false;
        if(!_buf.readString(x10)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::ETestQuality(__enum_temp__); }
        if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x14)) return false;
        if(!_buf.readVector2(v2)) return false;
        if(!_buf.readInt(t1)) return false;
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size()));k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::int32 _e;if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::bright::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::bright::int32 _k;  if(!_buf.readInt(_k)) return false; ::bright::int32 _v;  if(!_buf.readInt(_v)) return false;     k8[_k] = _v;}}
        {::bright::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::bright::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::bright::SharedPtr<test::DemoE2> _e;  if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}

        return true;
    }

    bool test::DefineFromExcel2::deserializeDefineFromExcel2(ByteBuf& _buf, ::bright::SharedPtr<test::DefineFromExcel2>& _out)
    {
        _out.reset(new test::DefineFromExcel2());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::DefineFromExcel2::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
        this->x8_Ref = ((test::TbDemoPrimitive*)(_tables["test.TbDemoPrimitive"]))->get(x8);
        x14->resolve(_tables);
        for(auto _e : k9) { _e->resolve(_tables); }
    }

    bool test::TestExcelBean1::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(x1)) return false;
        if(!_buf.readString(x2)) return false;
        if(!_buf.readInt(x3)) return false;
        if(!_buf.readFloat(x4)) return false;

        return true;
    }

    bool test::TestExcelBean1::deserializeTestExcelBean1(ByteBuf& _buf, ::bright::SharedPtr<test::TestExcelBean1>& _out)
    {
        _out.reset(new test::TestExcelBean1());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void test::TestExcelBean1::resolve(::bright::HashMap<::bright::String, void*>& _tables)
    {
    }
}
